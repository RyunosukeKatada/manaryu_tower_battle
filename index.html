<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>りゅうまなタワーバトル</title>
  <link href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css" rel="stylesheet" />
  <style>
    html, body {
      height: 100vh;
      width: 100vw;
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #eef;
    }
    #canvasWrapper {
      position: relative;
      width: 100vw;
      height: 100vh;
      max-width: none;
      max-height: none;
      padding-bottom: 0;
    }
    #canvasBackground {
      position: absolute;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: url('images/background.png') center/cover no-repeat;
      opacity: 0.25; z-index: 0;
    }
    #gameCanvas {
      width: 100vw !important;
      height: 100vh !important;
      display: block;
      background: transparent;
      z-index: 1;
      position: relative;
      touch-action: none;
    }
    .controls {
      position: absolute;
      left: 0; right: 0; bottom: 0;
      width: 100vw;
      display: flex;
      justify-content: space-between;
      gap: 0.5rem;
      padding: 0.5rem 0.5rem;
      background: rgba(255, 255, 255, 0.85);
      z-index: 2;
      box-sizing: border-box;
      height: 13vh;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      touch-action: manipulation;
    }
    .controls button {
      flex: 1 1 0;
      font-size: 2rem;
      min-width: 0;
      min-height: 5.5vh;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      touch-action: manipulation;
      border-radius: 1em;
    }
    #scoreDisplay { text-align: center; font-weight: bold; margin: 0.5rem auto; }
    #gameOver {
      display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.75); color: white; padding: 2rem; border-radius: 1rem;
      text-align: center; z-index: 10;
    }
  </style>
</head>
<body onclick="startBgmOnce()">
  <nav class="container-fluid">
    <ul>
      <li><strong>りゅうまなタワーバトル</strong></li>
    </ul>
    <ul>
      <li><a href="#" role="button" onclick="location.reload()">リセット</a></li>
    </ul>
  </nav>
  <audio id="bgm" src="audio/bgm.mp3" loop></audio>
  <audio id="seDrop" src="audio/se_drop.mp3"></audio>
  <audio id="seGameOver" src="audio/se_gameover.mp3"></audio>
  <div id="scoreDisplay">スコア: 0</div>
  <div id="canvasWrapper">
    <div id="canvasBackground"></div>
    <canvas id="gameCanvas" width="400" height="600"></canvas>
    <div class="controls">
      <button id="btnLeft">←</button>
      <button id="btnLeftRot">左回し</button>
      <button id="btnDrop">投下</button>
      <button id="btnRightRot">右回し</button>
      <button id="btnRight">→</button>
    </div>
    <div id="gameOver">
      <h3>Thank you for playing！</h3>
      <div id="finalScore"></div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
  <script>
    // スマホ用: BGMは初回タップでのみ再生可能
    let bgmStarted = false;
    function startBgmOnce() {
      if (!bgmStarted) {
        bgmStarted = true;
        const bgm = document.getElementById('bgm');
        bgm.play().catch(()=>{});
      }
      document.body.onclick = null;
    }
    const images = [
      {src: 'images/dumbbell.png', scale: 0.1},
      {src: 'images/fashion.png', scale: 0.12},
      {src: 'images/motorcycle.png', scale: 0.10},
      {src: 'images/man_kimono.png', scale: 0.2},
      {src: 'images/woman_barbell.png', scale: 0.2},
      {src: 'images/woman_kimono.png', scale: 0.2}
    ];
    // 画面サイズ自動計算
    let SCREEN_WIDTH = window.innerWidth;
    let SCREEN_HEIGHT = window.innerHeight;
    let BASE_Y = Math.floor(SCREEN_HEIGHT * 0.93);
    const BUTTON_HEIGHT = Math.floor(SCREEN_HEIGHT * 0.13);
    const {Engine, Render, Runner, World, Bodies, Body, Composite, Events} = Matter;
    const engine = Engine.create();
    engine.positionIterations = 16;
    engine.velocityIterations = 12;
    engine.constraintIterations = 6;
    const world = engine.world;
    const canvas = document.getElementById('gameCanvas');
    canvas.width = SCREEN_WIDTH;
    canvas.height = SCREEN_HEIGHT;
    const render = Render.create({
      canvas,
      engine,
      options: {width: SCREEN_WIDTH, height: SCREEN_HEIGHT, wireframes: false, background: 'transparent'}
    });
    Render.run(render);
    Runner.run(engine);

    // カメラ関連
    let cameraY = BASE_Y - (SCREEN_HEIGHT - BUTTON_HEIGHT - 20);
    let cameraTargetY = cameraY;

    // 台座
    World.add(world, [
      Bodies.rectangle(SCREEN_WIDTH/2, BASE_Y, SCREEN_WIDTH*0.7, 20, {isStatic: true, restitution: 0.0, render: {fillStyle: '#800020'}})
    ]);

    // 7px粒度ピクセル判定compound
    function createPixelMaskBody(obj, callback) {
      const img = new Image();
      img.src = obj.src;
      img.onload = () => {
        const scale = obj.scale;
        const w = img.width * scale, h = img.height * scale;
        const tmp = document.createElement('canvas');
        tmp.width = w; tmp.height = h;
        const ctx = tmp.getContext('2d');
        ctx.drawImage(img, 0, 0, w, h);
        const imageData = ctx.getImageData(0, 0, w, h);
        const parts = [];
        const block = 7;
        let spawnY = cameraY + 40;

        for (let y = 0; y < h; y += block) {
          for (let x = 0; x < w; x += block) {
            const i = (Math.floor(y) * w + Math.floor(x)) * 4;
            if (imageData.data[i + 3] > 32) {
              parts.push(Bodies.rectangle(
                SCREEN_WIDTH/2 - w/2 + x + block/2,
                spawnY + y + block/2,
                block, block,
                { friction: 0.8, frictionStatic: 1.0, restitution: 0.0, render: {visible: false} }
              ));
            }
          }
        }
        // スプライト矩形を重ねる
        const spriteBody = Bodies.rectangle(
          SCREEN_WIDTH/2, spawnY + h/2,
          w, h,
          { isSensor: true, render: {sprite: {texture: obj.src, xScale: scale, yScale: scale}} }
        );
        parts.push(spriteBody);
        const compound = Body.create({parts});
        Body.setStatic(compound, true);
        callback(compound);
      };
    }
    let previewBody = null;
    let moveInterval = null, rotateInterval = null;
    let score = 0, highScore = null;
    let isGameOver = false;

    function spawnPreview() {
      const obj = images[Math.floor(Math.random() * images.length)];
      createPixelMaskBody(obj, body => {
        previewBody = body;
        World.add(world, body);
      });
    }
    function dropBlock() {
      if (!previewBody) return;
      Body.setStatic(previewBody, false);
      document.getElementById('seDrop').play();
      monitorStability(previewBody);
      previewBody = null;
    }
    function monitorStability(body) {
      let still = 0;
      const interval = setInterval(() => {
        if (body.speed < 0.05) still += 100; else still = 0;
        if (still >= 1000) {
          clearInterval(interval);
          updateScore();
          spawnPreview();
        }
      }, 100);
    }
    function updateScore() {
      let minY = Infinity;
      const bodies = Composite.allBodies(world).filter(b => !b.isStatic);
      for (const body of bodies) {
        for (const part of body.parts) {
          if (!part.isSensor) {
            if (part.bounds.min.y < minY) minY = part.bounds.min.y;
          }
        }
      }
      if (minY === Infinity) return;
      const topY = minY;
      score = Math.round(BASE_Y - topY);
      document.getElementById('scoreDisplay').textContent = `スコア: ${score}`;
      if (highScore === null || score > highScore) {
        highScore = score;
        document.getElementById('scoreDisplay').textContent += `　ハイスコア: ${highScore}`;
      }
      if (topY < cameraY + 0.6 * SCREEN_HEIGHT) {
        let targetY = topY - 0.3 * SCREEN_HEIGHT;
        cameraTargetY = targetY;
      }
    }
    function updateCameraSmooth() {
      const alpha = 0.25;
      cameraY += (cameraTargetY - cameraY) * alpha;
      if (Math.abs(cameraY - cameraTargetY) < 1) cameraY = cameraTargetY;
      Render.lookAt(render, {
        min: {x: 0, y: cameraY},
        max: {x: SCREEN_WIDTH, y: cameraY + SCREEN_HEIGHT}
      });
    }
    setInterval(updateCameraSmooth, 16);

    // ボタン長押し最適化
    function setupButtonHold(btnId, onStart, onEnd) {
      const btn = document.getElementById(btnId);
      // PCマウス
      btn.addEventListener('mousedown', function(e) { e.preventDefault(); onStart(); });
      btn.addEventListener('mouseup', function(e) { e.preventDefault(); onEnd(); });
      btn.addEventListener('mouseleave', function(e) { e.preventDefault(); onEnd(); });
      // スマホタッチ
      btn.addEventListener('touchstart', function(e){e.preventDefault();onStart();});
      btn.addEventListener('touchend', function(e){e.preventDefault();onEnd();});
      btn.addEventListener('touchcancel', function(e){e.preventDefault();onEnd();});
    }
    setupButtonHold("btnLeft", ()=>startMove(-1), stopMove);
    setupButtonHold("btnRight", ()=>startMove(1), stopMove);
    setupButtonHold("btnLeftRot", ()=>startRotate(-1), stopRotate);
    setupButtonHold("btnRightRot", ()=>startRotate(1), stopRotate);
    // 投下はワンタップ
    document.getElementById("btnDrop").addEventListener('click', dropBlock);
    document.getElementById("btnDrop").addEventListener('touchend', function(e){e.preventDefault();dropBlock();});

    function startMove(dir) {
      if (!moveInterval) moveInterval = setInterval(() => {
        if (previewBody) Body.translate(previewBody, {x: dir * 2, y: 0});
      }, 16);
    }
    function stopMove() {clearInterval(moveInterval); moveInterval = null;}
    function startRotate(dir) {
      if (!rotateInterval) rotateInterval = setInterval(() => {
        if (previewBody) Body.rotate(previewBody, dir * Math.PI / 180);
      }, 16);
    }
    function stopRotate() {clearInterval(rotateInterval); rotateInterval = null;}
    // 毎フレームspriteBodyをcompound bodyに同期
    Events.on(engine, 'beforeUpdate', function() {
      const bodies = Composite.allBodies(world);
      for (const body of bodies) {
        if (body.parts && body.parts.length > 1) {
          for (const part of body.parts) {
            if (part.isSensor) {
              Body.setPosition(part, body.position);
              Body.setAngle(part, body.angle);
            }
          }
        }
      }
    });
    Events.on(engine, 'afterUpdate', () => {
      if (isGameOver) return;
      const bodies = Composite.allBodies(world);
      for (let body of bodies) {
        if (!body.isStatic) {
          if (body.parts && body.parts.length > 1) {
            for (const part of body.parts) {
              if (!part.isSensor && part.bounds.max.y > BASE_Y + 100) {
                isGameOver = true;
                document.getElementById('gameOver').style.display = 'block';
                document.getElementById('finalScore').textContent = `スコア: ${score}`;
                document.getElementById('seGameOver').play();
                Render.stop(render);
                Runner.stop(engine);
                break;
              }
            }
          } else {
            if (body.bounds.max.y > BASE_Y + 100) {
              isGameOver = true;
              document.getElementById('gameOver').style.display = 'block';
              document.getElementById('finalScore').textContent = `スコア: ${score}`;
              document.getElementById('seGameOver').play();
              Render.stop(render);
              Runner.stop(engine);
              break;
            }
          }
        }
      }
    });
    Render.lookAt(render, {
      min: {x: 0, y: cameraY},
      max: {x: SCREEN_WIDTH, y: cameraY + SCREEN_HEIGHT}
    });
    spawnPreview();
    // 画面リサイズ対応
    window.addEventListener('resize', () => {
      location.reload();
    });
  </script>
</body>
</html>
